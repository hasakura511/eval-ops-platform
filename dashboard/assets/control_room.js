const DEFAULT_SNAPSHOT_PATH = "../state/control_room_latest.json";
const POLL_INTERVAL_MS = 8000;

const statusClasses = {
  running: "status-running",
  failed: "status-failed",
  pending: "status-pending",
  blocked: "status-blocked",
  complete: "status-complete",
  completed: "status-complete",
  paused: "status-paused",
};

const byId = (id) => document.getElementById(id);

const toArray = (value) => (Array.isArray(value) ? value : []);

const safeText = (value, fallback = "—") =>
  value === undefined || value === null || value === "" ? fallback : value;

const normalizeStatus = (value) =>
  typeof value === "string" ? value.toLowerCase() : "unknown";

const relativeTime = (value) => {
  if (!value) return "—";
  const timestamp = new Date(value).getTime();
  if (Number.isNaN(timestamp)) return "—";
  const diffMs = Date.now() - timestamp;
  const diffSec = Math.floor(diffMs / 1000);
  if (diffSec < 0) return "in the future";
  if (diffSec < 60) return `${diffSec}s ago`;
  const diffMin = Math.floor(diffSec / 60);
  if (diffMin < 60) return `${diffMin}m ago`;
  const diffHr = Math.floor(diffMin / 60);
  if (diffHr < 24) return `${diffHr}h ago`;
  const diffDay = Math.floor(diffHr / 24);
  return `${diffDay}d ago`;
};

const metricValue = (metric) => {
  if (!metric) return "—";
  if (metric.unit) return `${metric.value} ${metric.unit}`;
  return metric.value;
};

const key = (value) => `<span class="json-key">${value}</span>`;

const explainers = {
  runStatus: {
    purpose:
      "Decide whether a run needs immediate triage, escalation, or can proceed.",
    inputs: [
      `Run status field ${key("projects[].tracks[].runs[].status")}.`,
    ],
    output: [
      "Pause, resume, or escalate the run based on its state.",
      "Align the next action with the current status.",
    ],
    failures: [
      "Status can be stale if the snapshot is old.",
      "Different runners may map states differently.",
    ],
    future: "Runner + judge pipeline writes status into the snapshot.",
  },
  runOwner: {
    purpose: "Show who owns the run so humans can route responsibility.",
    inputs: [
      `Owner id ${key("projects[].tracks[].runs[].owner.agent_id")}.`,
      `Owner label ${key("projects[].tracks[].runs[].owner.display_name")}.`,
    ],
    output: [
      "Reassign ownership or contact the owner for updates.",
      "Clarify whether the owner is a human or agent.",
    ],
    failures: [
      "Owner identity may be missing or outdated.",
      "Display name can hide the true accountable team.",
    ],
    future: "Human staffing system or router writes ownership into snapshot.",
  },
  runUpdated: {
    purpose: "Estimate how fresh the run information is.",
    inputs: [`Last update time ${key("projects[].tracks[].runs[].last_update_at")}.`],
    output: ["Decide whether to trust the run state or request a refresh."],
    failures: [
      "Clock skew can make updates look fresher or older than reality.",
      "Missing timestamps hide stalled runs.",
    ],
    future: "Runner heartbeat updates last_update_at in snapshot.",
  },
  runFailures: {
    purpose: "Quantify how many checks or tasks failed for this run.",
    inputs: [
      `Failure count ${key("projects[].tracks[].runs[].failure_count")}.`,
    ],
    output: ["Prioritize runs with higher failure counts for triage."],
    failures: [
      "Definition of failure_count is not standardized yet.",
      "Large runs can inflate counts without being critical.",
    ],
    future: "Audit subsystem writes failure_count into snapshot.",
  },
  runNext: {
    purpose: "Surface the next recommended action for a run.",
    inputs: [`Next action ${key("projects[].tracks[].runs[].next_action")}.`],
    output: ["Follow or override the suggested next action."],
    failures: [
      "Next action may be stale or autogenerated without context.",
      "Human intent may differ from suggested action.",
    ],
    future: "Human triage + router populate next_action.",
  },
  runMetrics: {
    purpose: "Expose compact run metrics to judge progress and quality.",
    inputs: [
      `Metric list ${key("projects[].tracks[].runs[].metrics_summary[]")}.`,
    ],
    output: ["Compare metrics across runs and detect regressions."],
    failures: [
      "Metrics lack defined units and thresholds in the snapshot.",
      "Derived metrics can hide underlying distribution shifts.",
    ],
    future: "Runner + judge pipeline emit metrics_summary.",
  },
  runArtifacts: {
    purpose: "Link to evidence that justifies the run state and decisions.",
    inputs: [
      `Artifact references ${key("projects[].tracks[].runs[].artifact_refs[]")}.`,
    ],
    output: ["Open artifacts to verify evidence and audit trails."],
    failures: [
      "Missing artifacts can mask decision rationale.",
      "Links may point to stale or incomplete records.",
    ],
    future: "Ledger + artifact store populate artifact_refs.",
  },
  runTodos: {
    purpose: "List open work items needed to move the run forward.",
    inputs: [`Todo list ${key("projects[].tracks[].runs[].todos[]")}.`],
    output: ["Assign, complete, or escalate todos."],
    failures: [
      "Todos may not capture blocked dependencies.",
      "Status may lag behind actual progress.",
    ],
    future: "Human tasking and runner queue populate todos.",
  },
  spotlightFailures: {
    purpose: "Surface the worst failing runs for immediate attention.",
    inputs: [
      `Failure count ${key("projects[].tracks[].runs[].failure_count")}.`,
      `Run id ${key("projects[].tracks[].runs[].run_id")}.`,
    ],
    output: ["Escalate the top failing runs first."],
    failures: [
      "Failure counts may not be normalized by run size.",
      "A single noisy run can dominate the list.",
    ],
    future: "Audit subsystem feeds failure_count into snapshot.",
  },
  nodeStatus: {
    purpose: "Summarize state for a hierarchy node (project/track/run/agent/todo).",
    inputs: [
      `Node status field ${key("projects[].status / tracks[].status / runs[].status")}.`,
    ],
    output: ["Route ownership or action based on node status."],
    failures: [
      "Status values may not be consistent across node types.",
      "Unknown states can be misread as nominal.",
    ],
    future: "Runner/human systems populate status in snapshot.",
  },
  alertSeverity: {
    purpose: "Show urgency for an alert so humans can prioritize response.",
    inputs: [`Severity ${key("alerts[].severity")}.`],
    output: ["Escalate warn/error alerts and log info alerts."],
    failures: [
      "Severity thresholds are not standardized yet.",
      "Alert volume can desensitize triage.",
    ],
    future: "Alerting subsystem emits severity into snapshot.",
  },
  alertRun: {
    purpose: "Tie an alert back to the run it references.",
    inputs: [`Run id ${key("alerts[].run_id")}.`],
    output: ["Open the run and assess impact."],
    failures: [
      "Missing run ids break traceability.",
      "Run id may refer to a deleted or merged run.",
    ],
    future: "Runner + alerting pipeline link alerts to runs.",
  },
};
const safeId = (value) =>
  String(value || "unknown").replace(/[^a-z0-9_-]/gi, "-").toLowerCase();

const buildExplainSection = (title, content) => {
  if (!content || (Array.isArray(content) && content.length === 0)) return "";
  const body = Array.isArray(content)
    ? `<ul>${content.map((item) => `<li>${item}</li>`).join("")}</ul>`
    : `<div>${content}</div>`;
  return `
    <div class="info-panel-section">
      <div class="info-panel-title">${title}</div>
      ${body}
    </div>
  `;
};

const explainPanelHtml = (id, label, config = {}, jsonKey = "") => {
  const keyHtml = jsonKey ? `<span class="json-key">${jsonKey}</span>` : "";
  const panel = `
    <span id="${id}" class="info-panel" role="region" aria-hidden="true">
      ${buildExplainSection("Purpose", config.purpose)}
      ${buildExplainSection("Inputs", config.inputs)}
      ${buildExplainSection("Output / Action", config.output)}
      ${buildExplainSection("Failure modes", config.failures)}
      ${buildExplainSection("Future link", config.future)}
    </span>
  `;
  return `
    <span class="info-wrap">
      <span class="info-label">${label}${keyHtml}</span>
      <button class="info-button" type="button" aria-label="Explain ${label}" aria-expanded="false" aria-controls="${id}">?</button>
      ${panel}
    </span>
  `;
};

const closeExplainPanels = () => {
  document.querySelectorAll(".info-button.is-open").forEach((button) => {
    button.classList.remove("is-open");
    button.setAttribute("aria-expanded", "false");
    const panelId = button.getAttribute("aria-controls");
    const panel = panelId ? document.getElementById(panelId) : null;
    if (panel) {
      panel.classList.remove("is-open");
      panel.setAttribute("aria-hidden", "true");
    }
  });
};

const initExplainPanels = () => {
  const buttons = document.querySelectorAll(".info-button");
  if (buttons.length === 0) return;
  buttons.forEach((button) => {
    if (button.dataset.explainBound === "true") return;
    button.dataset.explainBound = "true";
    button.setAttribute("aria-expanded", "false");
    button.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
      const isOpen = button.classList.contains("is-open");
      const panelId = button.getAttribute("aria-controls");
      const panel = panelId ? document.getElementById(panelId) : null;
      if (isOpen) {
        button.classList.remove("is-open");
        button.setAttribute("aria-expanded", "false");
        if (panel) {
          panel.classList.remove("is-open");
          panel.setAttribute("aria-hidden", "true");
        }
        return;
      }
      button.classList.add("is-open");
      button.setAttribute("aria-expanded", "true");
      if (panel) {
        panel.classList.add("is-open");
        panel.setAttribute("aria-hidden", "false");
      }
    });
  });

  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape") {
      closeExplainPanels();
    }
  });
};

const fetchSnapshot = async (path) => {
  const response = await fetch(path, { cache: "no-store" });
  if (!response.ok) {
    throw new Error(`Failed to load snapshot (${response.status})`);
  }
  return response.json();
};

const buildRunIndex = (snapshot) => {
  const projects = toArray(snapshot.projects);
  const runs = [];

  projects.forEach((project) => {
    toArray(project.tracks).forEach((track) => {
      toArray(track.runs).forEach((run) => {
        runs.push({
          project,
          track,
          run,
        });
      });
    });
  });

  return runs;
};

const buildAlertIndex = (snapshot) => toArray(snapshot.alerts);

const setStatusChip = (el, status) => {
  const normalized = normalizeStatus(status);
  el.textContent = status ? status.toUpperCase() : "UNKNOWN";
  el.className = `chip status ${statusClasses[normalized] || "status-unknown"}`;
};

const renderHeader = (snapshot) => {
  setText("snapshot-time", snapshot.as_of);
  setText("snapshot-health", safeText(snapshot.health?.status, "Nominal"));
  setText(
    "snapshot-freshness",
    snapshot.health?.data_freshness_seconds !== undefined
      ? `${snapshot.health.data_freshness_seconds}s`
      : "—"
  );
  setText(
    "snapshot-alerts",
    snapshot.health?.active_alerts_count !== undefined
      ? snapshot.health.active_alerts_count
      : "0"
  );
};

const setText = (id, value) => {
  const el = byId(id);
  if (!el) return;
  el.textContent = safeText(value);
};

const renderFilters = (snapshot) => {
  const projectSelect = byId("filter-project");
  const trackSelect = byId("filter-track");
  const statusSelect = byId("filter-status");
  const ownerSelect = byId("filter-owner");

  if (!projectSelect || !trackSelect || !statusSelect || !ownerSelect) return;

  const projects = toArray(snapshot.projects);
  const tracks = new Map();
  const statuses = new Set();
  const owners = new Map();

  projects.forEach((project) => {
    toArray(project.tracks).forEach((track) => {
      tracks.set(track.track_id, track.name || track.track_id);
      toArray(track.runs).forEach((run) => {
        if (run.status) statuses.add(run.status);
        if (run.owner?.agent_id) {
          owners.set(run.owner.agent_id, run.owner.display_name || run.owner.agent_id);
        }
      });
    });
  });

  fillSelect(projectSelect, projects.map((project) => ({
    value: project.project_id,
    label: project.name || project.project_id,
  })));
  fillSelect(trackSelect, Array.from(tracks.entries()).map(([value, label]) => ({
    value,
    label,
  })));
  fillSelect(statusSelect, Array.from(statuses).sort().map((value) => ({
    value,
    label: value,
  })));
  fillSelect(ownerSelect, Array.from(owners.entries()).map(([value, label]) => ({
    value,
    label,
  })));

  applyFilterFromQuery();
};

const fillSelect = (select, options) => {
  const current = select.value;
  select.innerHTML = '<option value="">All</option>';
  options.forEach((option) => {
    const node = document.createElement("option");
    node.value = option.value;
    node.textContent = option.label;
    select.appendChild(node);
  });
  if (current) select.value = current;
};

const applyFilterFromQuery = () => {
  const params = new URLSearchParams(window.location.search);
  const applyValue = (id, key) => {
    const el = byId(id);
    if (!el) return;
    const value = params.get(key);
    if (value) el.value = value;
  };
  applyValue("filter-project", "project");
  applyValue("filter-track", "track");
  applyValue("filter-status", "status");
  applyValue("filter-owner", "owner");
  applyValue("filter-search", "search");
};

const collectFilters = () => ({
  project: byId("filter-project")?.value || "",
  track: byId("filter-track")?.value || "",
  status: byId("filter-status")?.value || "",
  owner: byId("filter-owner")?.value || "",
  search: (byId("filter-search")?.value || "").toLowerCase(),
});

const matchesFilter = (item, filters) => {
  if (filters.project && item.project.project_id !== filters.project) return false;
  if (filters.track && item.track.track_id !== filters.track) return false;
  if (filters.status && item.run.status !== filters.status) return false;
  if (filters.owner && item.run.owner?.agent_id !== filters.owner) return false;
  if (filters.search) {
    const haystack = [
      item.project.name,
      item.track.name,
      item.run.run_id,
      item.run.next_action,
      item.run.owner?.display_name,
    ]
      .filter(Boolean)
      .join(" ")
      .toLowerCase();
    if (!haystack.includes(filters.search)) return false;
  }
  return true;
};

const renderWorkboard = (snapshot) => {
  const list = byId("workboard-list");
  if (!list) return;
  const filters = collectFilters();
  const runs = buildRunIndex(snapshot).filter((item) =>
    matchesFilter(item, filters)
  );

  list.innerHTML = "";

  if (runs.length === 0) {
    list.innerHTML = '<div class="empty">No runs match current filters.</div>';
    return;
  }

  runs.forEach((item) => {
    const { project, track, run } = item;
    const card = document.createElement("div");
    card.className = "run-card";

    const header = document.createElement("div");
    header.className = "run-header";

    const title = document.createElement("div");
    title.className = "run-title";
    title.innerHTML = `
      <div class="run-name">${safeText(run.run_id)}</div>
      <div class="run-subtitle">${safeText(project.name)} · ${safeText(track.name)}</div>
    `;

    const statusChip = document.createElement("span");
    setStatusChip(statusChip, run.status);
    const statusWrap = document.createElement("div");
    statusWrap.className = "status-chip-group";
    statusWrap.innerHTML = explainPanelHtml(
      `info-run-status-${safeId(run.run_id)}`,
      "Status",
      explainers.runStatus,
      "projects[].tracks[].runs[].status"
    );
    statusWrap.appendChild(statusChip);

    const meta = document.createElement("div");
    meta.className = "run-meta";
    meta.innerHTML = `
      <div>${explainPanelHtml(
        `info-run-owner-${safeId(run.run_id)}`,
        "Owner",
        explainers.runOwner,
        "projects[].tracks[].runs[].owner.display_name"
      )} ${safeText(run.owner?.display_name)}</div>
      <div>${explainPanelHtml(
        `info-run-updated-${safeId(run.run_id)}`,
        "Updated",
        explainers.runUpdated,
        "projects[].tracks[].runs[].last_update_at"
      )} ${relativeTime(run.last_update_at)}</div>
      <div>${explainPanelHtml(
        `info-run-failures-${safeId(run.run_id)}`,
        "Failures",
        explainers.runFailures,
        "projects[].tracks[].runs[].failure_count"
      )} ${safeText(run.failure_count, 0)}</div>
      <div>${explainPanelHtml(
        `info-run-next-${safeId(run.run_id)}`,
        "Next",
        explainers.runNext,
        "projects[].tracks[].runs[].next_action"
      )} ${safeText(run.next_action)}</div>
    `;

    const metrics = document.createElement("div");
    metrics.className = "chip-row";
    if (toArray(run.metrics_summary).length > 0) {
      const metricsLabel = document.createElement("span");
      metricsLabel.innerHTML = explainPanelHtml(
        `info-run-metrics-${safeId(run.run_id)}`,
        "Metrics",
        explainers.runMetrics,
        "projects[].tracks[].runs[].metrics_summary[]"
      );
      metrics.appendChild(metricsLabel);
    }
    toArray(run.metrics_summary).forEach((metric) => {
      const chip = document.createElement("span");
      chip.className = "chip neutral";
      chip.textContent = `${metric.name}: ${metricValue(metric)}`;
      metrics.appendChild(chip);
    });

    const artifacts = document.createElement("div");
    artifacts.className = "artifact-links";
    if (toArray(run.artifact_refs).length > 0) {
      const artifactLabel = document.createElement("span");
      artifactLabel.innerHTML = explainPanelHtml(
        `info-run-artifacts-${safeId(run.run_id)}`,
        "Artifacts",
        explainers.runArtifacts,
        "projects[].tracks[].runs[].artifact_refs[]"
      );
      artifacts.appendChild(artifactLabel);
    }
    toArray(run.artifact_refs).forEach((artifact) => {
      const link = document.createElement("a");
      link.href = artifact.href || "#";
      link.textContent = artifact.label || artifact.artifact_id;
      artifacts.appendChild(link);
    });

    const todoDrawer = document.createElement("details");
    todoDrawer.className = "todo-drawer";
    const summary = document.createElement("summary");
    summary.innerHTML = `${explainPanelHtml(
      `info-run-todos-${safeId(run.run_id)}`,
      "Todos",
      explainers.runTodos,
      "projects[].tracks[].runs[].todos[]"
    )} <span class="todo-count">(${toArray(run.todos).length})</span>`;
    todoDrawer.appendChild(summary);

    const todoList = document.createElement("div");
    todoList.className = "todo-list";

    if (toArray(run.todos).length === 0) {
      todoList.innerHTML = '<div class="empty">No todos assigned.</div>';
    } else {
      toArray(run.todos).forEach((todo) => {
        const todoItem = document.createElement("div");
        todoItem.className = "todo-item";
        todoItem.innerHTML = `
          <div>
            <div class="todo-title">${safeText(todo.title)}</div>
            <div class="todo-meta">
              ${safeText(todo.status)} · ${relativeTime(todo.updated_at)} · ${safeText(
          todo.owner_agent_id
        )}
            </div>
            <div class="todo-meta">${safeText(todo.blocking_reason)}</div>
          </div>
        `;
        const refs = document.createElement("div");
        refs.className = "todo-artifacts";
        toArray(todo.artifact_refs).forEach((artifact) => {
          const link = document.createElement("a");
          link.href = artifact.href || "#";
          link.textContent = artifact.label || artifact.artifact_id;
          refs.appendChild(link);
        });
        todoItem.appendChild(refs);
        todoList.appendChild(todoItem);
      });
    }

    todoDrawer.appendChild(todoList);

    header.appendChild(title);
    header.appendChild(statusWrap);

    card.appendChild(header);
    card.appendChild(meta);
    if (metrics.children.length > 0) card.appendChild(metrics);
    if (artifacts.children.length > 0) card.appendChild(artifacts);
    card.appendChild(todoDrawer);

    list.appendChild(card);
  });
};

const renderSpotlight = (snapshot) => {
  const spotlight = byId("failure-spotlight");
  if (!spotlight) return;
  const runs = buildRunIndex(snapshot)
    .map((item) => ({
      ...item,
      failure_count: item.run.failure_count || 0,
    }))
    .filter((item) => item.failure_count > 0)
    .sort((a, b) => b.failure_count - a.failure_count)
    .slice(0, 5);

  spotlight.innerHTML = "";

  if (runs.length === 0) {
    spotlight.innerHTML = '<div class="empty">No failures reported.</div>';
    return;
  }

  runs.forEach((item) => {
    const card = document.createElement("div");
    card.className = "spotlight-card";
    const failureLabel = explainPanelHtml(
      `info-spotlight-failures-${safeId(item.run.run_id)}`,
      "Failures",
      explainers.spotlightFailures,
      "projects[].tracks[].runs[].failure_count"
    );
    card.innerHTML = `
      <div class="spotlight-title">${safeText(item.run.run_id)}</div>
      <div class="spotlight-meta">${safeText(item.project.name)} · ${safeText(
      item.track.name
    )}</div>
      <div class="spotlight-meta">${failureLabel} ${safeText(
      item.run.failure_count
    )}</div>
    `;
    spotlight.appendChild(card);
  });
};

const renderTodoFeed = (snapshot) => {
  const feed = byId("todo-feed");
  if (!feed) return;
  const todos = [];
  buildRunIndex(snapshot).forEach((item) => {
    toArray(item.run.todos).forEach((todo) => {
      todos.push({
        todo,
        run: item.run,
        project: item.project,
        track: item.track,
      });
    });
  });

  todos.sort(
    (a, b) =>
      new Date(b.todo.updated_at || 0).getTime() -
      new Date(a.todo.updated_at || 0).getTime()
  );

  feed.innerHTML = "";

  if (todos.length === 0) {
    feed.innerHTML = '<div class="empty">No open todos.</div>';
    return;
  }

  todos.slice(0, 8).forEach((item) => {
    const row = document.createElement("div");
    row.className = "todo-feed-row";
    row.innerHTML = `
      <div>
        <div class="todo-title">${safeText(item.todo.title)}</div>
        <div class="todo-meta">${safeText(item.project.name)} · ${safeText(
      item.track.name
    )} · ${safeText(item.run.run_id)}</div>
      </div>
      <div class="todo-meta">${safeText(item.todo.status)} · ${relativeTime(
      item.todo.updated_at
    )}</div>
    `;
    feed.appendChild(row);
  });
};

const renderHierarchy = (snapshot) => {
  const tree = byId("hierarchy-tree");
  if (!tree) return;
  tree.innerHTML = "";

  const nodeIndex = new Map();

  const createNode = (type, id, label, status, extra) => {
    const statusId = `info-node-status-${safeId(`${type}-${id}`)}`;
    const node = document.createElement("button");
    node.type = "button";
    node.className = "hierarchy-node";
    node.dataset.nodeKey = `${type}:${id}`;
    node.innerHTML = `
      <div class="hierarchy-node-header">
        <span class="hierarchy-node-title">${label}</span>
        <span class="status-chip-group">
          ${explainPanelHtml(statusId, "Status", explainers.nodeStatus, "status")}
          <span class="chip status">${safeText(status).toUpperCase()}</span>
        </span>
      </div>
      <div class="hierarchy-node-meta">${safeText(extra)}</div>
    `;
    const chip = node.querySelector(".chip.status");
    setStatusChip(chip, status);
    return node;
  };

  toArray(snapshot.projects).forEach((project) => {
    const projectNode = createNode(
      "project",
      project.project_id,
      project.name || project.project_id,
      project.status,
      `${toArray(project.tracks).length} tracks`
    );
    nodeIndex.set(`project:${project.project_id}`, { type: "project", data: project });

    const projectGroup = document.createElement("div");
    projectGroup.className = "hierarchy-group";
    projectGroup.appendChild(projectNode);

    toArray(project.tracks).forEach((track) => {
      const trackNode = createNode(
        "track",
        track.track_id,
        track.name || track.track_id,
        track.status,
        `${toArray(track.runs).length} runs · ${safeText(track.type)}`
      );
      nodeIndex.set(`track:${track.track_id}`, { type: "track", data: track });
      const trackGroup = document.createElement("div");
      trackGroup.className = "hierarchy-group nested";
      trackGroup.appendChild(trackNode);

      toArray(track.runs).forEach((run) => {
        const runNode = createNode(
          "run",
          run.run_id,
          run.run_id,
          run.status,
          `${safeText(run.owner?.display_name)} · ${safeText(run.next_action)}`
        );
        nodeIndex.set(`run:${run.run_id}`, { type: "run", data: run });
        const runGroup = document.createElement("div");
        runGroup.className = "hierarchy-group nested";
        runGroup.appendChild(runNode);

        if (run.owner?.agent_id) {
          const agentNode = createNode(
            "agent",
            run.owner.agent_id,
            run.owner.display_name || run.owner.agent_id,
            run.owner.status || "active",
            run.owner.role || ""
          );
          nodeIndex.set(`agent:${run.owner.agent_id}`, {
            type: "agent",
            data: run.owner,
          });
          const agentGroup = document.createElement("div");
          agentGroup.className = "hierarchy-group nested";
          agentGroup.appendChild(agentNode);

          toArray(run.todos).forEach((todo) => {
            const todoNode = createNode(
              "todo",
              todo.todo_id,
              todo.title || todo.todo_id,
              todo.status,
              `Updated ${relativeTime(todo.updated_at)}`
            );
            nodeIndex.set(`todo:${todo.todo_id}`, { type: "todo", data: todo });
            const todoGroup = document.createElement("div");
            todoGroup.className = "hierarchy-group nested";
            todoGroup.appendChild(todoNode);
            agentGroup.appendChild(todoGroup);
          });
          runGroup.appendChild(agentGroup);
        }
        trackGroup.appendChild(runGroup);
      });
      projectGroup.appendChild(trackGroup);
    });

    tree.appendChild(projectGroup);
  });

  const detailPanel = byId("node-detail");
  if (!detailPanel) return;

  tree.querySelectorAll(".hierarchy-node").forEach((node) => {
    node.addEventListener("click", () => {
      const key = node.dataset.nodeKey;
      const entry = nodeIndex.get(key);
      if (!entry) return;
      renderNodeDetail(detailPanel, entry);
    });
  });
};

const renderNodeDetail = (panel, entry) => {
  panel.innerHTML = "";
  const header = document.createElement("div");
  header.className = "detail-header";
  header.textContent = `${entry.type.toUpperCase()} · ${safeText(
    entry.data.name || entry.data.run_id || entry.data.todo_id || entry.data.agent_id
  )}`;

  const list = document.createElement("div");
  list.className = "detail-list";

  Object.entries(entry.data).forEach(([key, value]) => {
    if (Array.isArray(value)) return;
    if (value && typeof value === "object") return;
    const row = document.createElement("div");
    row.className = "detail-row";
    row.innerHTML = `<span>${key}</span><span>${safeText(value)}</span>`;
    list.appendChild(row);
  });

  const artifacts = document.createElement("div");
  artifacts.className = "detail-artifacts";
  const artifactRefs = toArray(entry.data.artifact_refs);
  if (artifactRefs.length > 0) {
    const title = document.createElement("div");
    title.className = "detail-subtitle";
    title.textContent = "Artifacts";
    artifacts.appendChild(title);
    artifactRefs.forEach((artifact) => {
      const link = document.createElement("a");
      link.href = artifact.href || "#";
      link.textContent = artifact.label || artifact.artifact_id;
      artifacts.appendChild(link);
    });
  }

  panel.appendChild(header);
  panel.appendChild(list);
  if (artifactRefs.length > 0) panel.appendChild(artifacts);
};

const renderAlerts = (snapshot) => {
  const alerts = byId("alerts-rail");
  if (!alerts) return;
  const alertItems = buildAlertIndex(snapshot);
  alerts.innerHTML = "";

  if (alertItems.length === 0) {
    alerts.innerHTML = '<div class="empty">No alerts.</div>';
    return;
  }

  alertItems.forEach((alert) => {
    const card = document.createElement("div");
    card.className = "alert-card";
    const severityId = `info-alert-severity-${safeId(alert.alert_id)}`;
    const runInfoId = `info-alert-run-${safeId(alert.alert_id)}`;
    card.innerHTML = `
      <div class="alert-header">
        <span class="status-chip-group">
          ${explainPanelHtml(
            severityId,
            "Severity",
            explainers.alertSeverity,
            "alerts[].severity"
          )}
          <span class="chip ${alert.severity}">${safeText(alert.severity)}</span>
        </span>
        <span>${relativeTime(alert.timestamp)}</span>
      </div>
      <div class="alert-message">${safeText(alert.message)}</div>
      <div class="alert-meta">${explainPanelHtml(
        runInfoId,
        "Run",
        explainers.alertRun,
        "alerts[].run_id"
      )} ${safeText(alert.run_id)}</div>
    `;
    const refs = document.createElement("div");
    refs.className = "alert-artifacts";
    toArray(alert.artifact_refs).forEach((artifact) => {
      const link = document.createElement("a");
      link.href = artifact.href || "#";
      link.textContent = artifact.label || artifact.artifact_id;
      refs.appendChild(link);
    });
    card.appendChild(refs);
    alerts.appendChild(card);
  });
};

const renderSnapshot = (snapshot) => {
  renderHeader(snapshot);
  renderFilters(snapshot);
  renderWorkboard(snapshot);
  renderSpotlight(snapshot);
  renderTodoFeed(snapshot);
  renderHierarchy(snapshot);
  renderAlerts(snapshot);
  initExplainPanels();
};

const startPolling = (path) => {
  const statusLabel = byId("snapshot-status");
  const load = async () => {
    try {
      const snapshot = await fetchSnapshot(path);
      renderSnapshot(snapshot);
      if (statusLabel) statusLabel.textContent = "Live";
    } catch (error) {
      if (statusLabel) statusLabel.textContent = "Offline";
      console.error(error);
    }
  };

  load();
  setInterval(load, POLL_INTERVAL_MS);
};

const initControls = () => {
  const controls = [
    "filter-project",
    "filter-track",
    "filter-status",
    "filter-owner",
    "filter-search",
  ];
  controls.forEach((id) => {
    const control = byId(id);
    if (!control) return;
    control.addEventListener("change", () => {
      fetchSnapshot(getSnapshotPath()).then(renderSnapshot).catch(console.error);
    });
    control.addEventListener("input", () => {
      fetchSnapshot(getSnapshotPath()).then(renderSnapshot).catch(console.error);
    });
  });
};

const initJsonKeyToggle = () => {
  const toggle = byId("toggle-json-keys");
  if (!toggle) return;
  toggle.addEventListener("change", () => {
    document.body.classList.toggle("show-json-keys", toggle.checked);
  });
};

const getSnapshotPath = () => {
  const params = new URLSearchParams(window.location.search);
  return params.get("source") || DEFAULT_SNAPSHOT_PATH;
};

const boot = () => {
  initControls();
  initExplainPanels();
  initJsonKeyToggle();
  startPolling(getSnapshotPath());
};

boot();
