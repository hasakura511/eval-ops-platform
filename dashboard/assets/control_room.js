const DEFAULT_SNAPSHOT_PATH = "state/control_room_latest.json";
const LEGACY_SNAPSHOT_PATH = "state/latest.json";
const POLL_INTERVAL_MS = 8000;
const STALE_THRESHOLD_SECONDS = 30;
const REFRESH_LABEL_INTERVAL_MS = 1000;
const STREAM_ENDPOINT = "/api/v1/control-room/stream";
const SNAPSHOT_ENDPOINT = "/api/v1/control-room/snapshot";
const FLASH_DURATION_MS = 1200;
const SSE_RETRY_BASE_MS = 2000;
const SSE_RETRY_MAX_MS = 30000;

const statusClasses = {
  running: "status-running",
  failed: "status-failed",
  pending: "status-pending",
  blocked: "status-blocked",
  complete: "status-complete",
  completed: "status-complete",
  paused: "status-paused",
};

const byId = (id) => document.getElementById(id);

const toArray = (value) => (Array.isArray(value) ? value : []);

const safeText = (value, fallback = "—") =>
  value === undefined || value === null || value === "" ? fallback : value;

const normalizeStatus = (value) =>
  typeof value === "string" ? value.toLowerCase() : "unknown";

const relativeTime = (value) => {
  if (!value) return "—";
  const timestamp = new Date(value).getTime();
  if (Number.isNaN(timestamp)) return "—";
  const diffMs = Date.now() - timestamp;
  const diffSec = Math.floor(diffMs / 1000);
  if (diffSec < 0) return "in the future";
  if (diffSec < 60) return `${diffSec}s ago`;
  const diffMin = Math.floor(diffSec / 60);
  if (diffMin < 60) return `${diffMin}m ago`;
  const diffHr = Math.floor(diffMin / 60);
  if (diffHr < 24) return `${diffHr}h ago`;
  const diffDay = Math.floor(diffHr / 24);
  return `${diffDay}d ago`;
};

const metricValue = (metric) => {
  if (!metric) return "—";
  if (metric.unit) return `${metric.value} ${metric.unit}`;
  return metric.value;
};

const key = (value) => `<span class="json-key">${value}</span>`;

const explainers = {
  runStatus: {
    purpose:
      "Decide whether a run needs immediate triage, escalation, or can proceed.",
    inputs: [
      `Run status field ${key("projects[].tracks[].runs[].status")}.`,
    ],
    output: [
      "Pause, resume, or escalate the run based on its state.",
      "Align the next action with the current status.",
    ],
    failures: [
      "Status can be stale if the snapshot is old.",
      "Different runners may map states differently.",
    ],
    future: "Runner + judge pipeline writes status into the snapshot.",
  },
  runOwner: {
    purpose: "Show who owns the run so humans can route responsibility.",
    inputs: [
      `Owner id ${key("projects[].tracks[].runs[].owner.agent_id")}.`,
      `Owner label ${key("projects[].tracks[].runs[].owner.display_name")}.`,
    ],
    output: [
      "Reassign ownership or contact the owner for updates.",
      "Clarify whether the owner is a human or agent.",
    ],
    failures: [
      "Owner identity may be missing or outdated.",
      "Display name can hide the true accountable team.",
    ],
    future: "Human staffing system or router writes ownership into snapshot.",
  },
  runUpdated: {
    purpose: "Estimate how fresh the run information is.",
    inputs: [`Last update time ${key("projects[].tracks[].runs[].last_update_at")}.`],
    output: ["Decide whether to trust the run state or request a refresh."],
    failures: [
      "Clock skew can make updates look fresher or older than reality.",
      "Missing timestamps hide stalled runs.",
    ],
    future: "Runner heartbeat updates last_update_at in snapshot.",
  },
  runFailures: {
    purpose: "Quantify how many checks or tasks failed for this run.",
    inputs: [
      `Failure count ${key("projects[].tracks[].runs[].failure_count")}.`,
    ],
    output: ["Prioritize runs with higher failure counts for triage."],
    failures: [
      "Definition of failure_count is not standardized yet.",
      "Large runs can inflate counts without being critical.",
    ],
    future: "Audit subsystem writes failure_count into snapshot.",
  },
  runNext: {
    purpose: "Surface the next recommended action for a run.",
    inputs: [`Next action ${key("projects[].tracks[].runs[].next_action")}.`],
    output: ["Follow or override the suggested next action."],
    failures: [
      "Next action may be stale or autogenerated without context.",
      "Human intent may differ from suggested action.",
    ],
    future: "Human triage + router populate next_action.",
  },
  runMetrics: {
    purpose: "Expose compact run metrics to judge progress and quality.",
    inputs: [
      `Metric list ${key("projects[].tracks[].runs[].metrics_summary[]")}.`,
    ],
    output: ["Compare metrics across runs and detect regressions."],
    failures: [
      "Metrics lack defined units and thresholds in the snapshot.",
      "Derived metrics can hide underlying distribution shifts.",
    ],
    future: "Runner + judge pipeline emit metrics_summary.",
  },
  runArtifacts: {
    purpose: "Link to evidence that justifies the run state and decisions.",
    inputs: [
      `Artifact references ${key("projects[].tracks[].runs[].artifact_refs[]")}.`,
    ],
    output: ["Open artifacts to verify evidence and audit trails."],
    failures: [
      "Missing artifacts can mask decision rationale.",
      "Links may point to stale or incomplete records.",
    ],
    future: "Ledger + artifact store populate artifact_refs.",
  },
  runTodos: {
    purpose: "List open work items needed to move the run forward.",
    inputs: [`Todo list ${key("projects[].tracks[].runs[].todos[]")}.`],
    output: ["Assign, complete, or escalate todos."],
    failures: [
      "Todos may not capture blocked dependencies.",
      "Status may lag behind actual progress.",
    ],
    future: "Human tasking and runner queue populate todos.",
  },
  spotlightFailures: {
    purpose: "Surface the worst failing runs for immediate attention.",
    inputs: [
      `Failure count ${key("projects[].tracks[].runs[].failure_count")}.`,
      `Run id ${key("projects[].tracks[].runs[].run_id")}.`,
    ],
    output: ["Escalate the top failing runs first."],
    failures: [
      "Failure counts may not be normalized by run size.",
      "A single noisy run can dominate the list.",
    ],
    future: "Audit subsystem feeds failure_count into snapshot.",
  },
  nodeStatus: {
    purpose: "Summarize state for a hierarchy node (project/track/run/agent/todo).",
    inputs: [
      `Node status field ${key("projects[].status / tracks[].status / runs[].status")}.`,
    ],
    output: ["Route ownership or action based on node status."],
    failures: [
      "Status values may not be consistent across node types.",
      "Unknown states can be misread as nominal.",
    ],
    future: "Runner/human systems populate status in snapshot.",
  },
  alertSeverity: {
    purpose: "Show urgency for an alert so humans can prioritize response.",
    inputs: [`Severity ${key("alerts[].severity")}.`],
    output: ["Escalate warn/error alerts and log info alerts."],
    failures: [
      "Severity thresholds are not standardized yet.",
      "Alert volume can desensitize triage.",
    ],
    future: "Alerting subsystem emits severity into snapshot.",
  },
  alertRun: {
    purpose: "Tie an alert back to the run it references.",
    inputs: [`Run id ${key("alerts[].run_id")}.`],
    output: ["Open the run and assess impact."],
    failures: [
      "Missing run ids break traceability.",
      "Run id may refer to a deleted or merged run.",
    ],
    future: "Runner + alerting pipeline link alerts to runs.",
  },
};

const safeId = (value) =>
  String(value || "unknown").replace(/[^a-z0-9_-]/gi, "-").toLowerCase();

const buildExplainSection = (title, content) => {
  if (!content || (Array.isArray(content) && content.length === 0)) return "";
  const body = Array.isArray(content)
    ? `<ul>${content.map((item) => `<li>${item}</li>`).join("")}</ul>`
    : `<div>${content}</div>`;
  return `
    <div class="info-panel-section">
      <div class="info-panel-title">${title}</div>
      ${body}
    </div>
  `;
};

const explainPanelHtml = (id, label, config = {}, jsonKey = "") => {
  const keyHtml = jsonKey ? `<span class="json-key">${jsonKey}</span>` : "";
  const panel = `
    <span id="${id}" class="info-panel" role="region" aria-hidden="true">
      ${buildExplainSection("Purpose", config.purpose)}
      ${buildExplainSection("Inputs", config.inputs)}
      ${buildExplainSection("Output / Action", config.output)}
      ${buildExplainSection("Failure modes", config.failures)}
      ${buildExplainSection("Future link", config.future)}
    </span>
  `;
  return `
    <span class="info-wrap">
      <span class="info-label">${label}${keyHtml}</span>
      <button class="info-button" type="button" aria-label="Explain ${label}" aria-expanded="false" aria-controls="${id}">?</button>
      ${panel}
    </span>
  `;
};

const closeExplainPanels = () => {
  document.querySelectorAll(".info-button.is-open").forEach((button) => {
    button.classList.remove("is-open");
    button.setAttribute("aria-expanded", "false");
    const panelId = button.getAttribute("aria-controls");
    const panel = panelId ? document.getElementById(panelId) : null;
    if (panel) {
      panel.classList.remove("is-open");
      panel.setAttribute("aria-hidden", "true");
    }
  });
};

const initExplainPanels = () => {
  const buttons = document.querySelectorAll(".info-button");
  if (buttons.length === 0) return;
  buttons.forEach((button) => {
    if (button.dataset.explainBound === "true") return;
    button.dataset.explainBound = "true";
    button.setAttribute("aria-expanded", "false");
    button.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
      const isOpen = button.classList.contains("is-open");
      const panelId = button.getAttribute("aria-controls");
      const panel = panelId ? document.getElementById(panelId) : null;
      if (isOpen) {
        button.classList.remove("is-open");
        button.setAttribute("aria-expanded", "false");
        if (panel) {
          panel.classList.remove("is-open");
          panel.setAttribute("aria-hidden", "true");
        }
        return;
      }
      button.classList.add("is-open");
      button.setAttribute("aria-expanded", "true");
      if (panel) {
        panel.classList.add("is-open");
        panel.setAttribute("aria-hidden", "false");
      }
    });
  });

  if (!explainEscapeBound) {
    explainEscapeBound = true;
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        closeExplainPanels();
      }
    });
  }
};

const fetchSnapshot = async (path) => {
  const response = await fetch(path, { cache: "no-store" });
  if (!response.ok) {
    throw new Error(`Failed to load snapshot (${response.status})`);
  }
  return response.json();
};

const normalizeTimestamp = (value) => {
  if (!value) return null;
  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? null : parsed.toISOString();
};

const computeFreshness = (asOf) =>
  asOf ? Math.max(0, Math.floor((Date.now() - new Date(asOf).getTime()) / 1000)) : null;

const normalizeSeverity = (value) =>
  typeof value === "string" ? value.toLowerCase() : "info";

const normalizeControlRoomSnapshot = (raw = {}) => {
  const asOf = normalizeTimestamp(raw.as_of || raw.meta?.timestamp);
  const health = raw.health || {};
  const dataFreshness =
    health.data_freshness_seconds ?? computeFreshness(asOf);

  return {
    schema_version: raw.schema_version || "control-room-snapshot-v0",
    as_of: asOf,
    health: {
      status: health.status || raw.meta?.global_status || "Unknown",
      data_freshness_seconds: dataFreshness,
      active_alerts_count:
        health.active_alerts_count ??
        (Array.isArray(raw.alerts) ? raw.alerts.length : 0),
    },
    projects: toArray(raw.projects),
    alerts: toArray(raw.alerts),
  };
};

const mapLegacyStatus = (value) => {
  const status = typeof value === "string" ? value.toUpperCase() : "UNKNOWN";
  if (status.includes("CRITICAL") || status.includes("AUDIT_FAIL")) return "failed";
  if (status.includes("DEREGULATION") || status.includes("HIGH_ENTROPY")) return "blocked";
  if (status.includes("SANDBOX")) return "paused";
  if (status.includes("NOMINAL")) return "running";
  return "pending";
};

const artifactRefFromLegacy = (ref) => {
  if (!ref) return null;
  if (typeof ref !== "string") return null;
  if (ref.startsWith("artifact:")) {
    const artifactId = ref.replace("artifact:", "");
    return {
      artifact_id: artifactId,
      label: artifactId,
      href: `/records/artifacts/${artifactId}.json`,
    };
  }
  return {
    artifact_id: ref,
    label: ref,
    href: null,
  };
};

const normalizeLegacySnapshot = (raw = {}) => {
  const asOf = normalizeTimestamp(raw.meta?.timestamp);
  const status = raw.meta?.global_status || "Unknown";
  const units = toArray(raw.B_t?.A_t?.units);
  const projectId = raw.meta?.project_id || "legacy-project";
  const runs = units.map((unit) => ({
    run_id: unit.unit_id || "unit",
    status: mapLegacyStatus(status),
    last_update_at: asOf,
    owner: {
      agent_id: unit.unit_id || "unit",
      display_name: unit.jurisdiction || unit.unit_id || "unit",
      role: "unit",
      status: "active",
    },
    failure_count: toArray(unit.variance_memos).length,
    next_action: unit.mandate_ref ? `Review ${unit.mandate_ref}` : "Review mandate",
    todos: [],
    metrics_summary: [
      { name: "D_i", value: unit.D_i ?? "—", unit: null },
      {
        name: "Discretion spent",
        value: unit.discretion_spent_this_iter ?? "—",
        unit: null,
      },
    ],
    artifact_refs: [
      artifactRefFromLegacy(unit.mandate_ref),
      ...toArray(unit.variance_memos).map(artifactRefFromLegacy),
    ].filter(Boolean),
  }));

  const alerts = toArray(raw.alerts).map((alert, index) => ({
    alert_id: alert.alert_id || `legacy-alert-${index + 1}`,
    severity: normalizeSeverity(alert.severity),
    run_id: alert.run_id || null,
    message: alert.message || alert.type || "Legacy alert",
    timestamp: asOf,
    artifact_refs: toArray(alert.evidence_refs)
      .map(artifactRefFromLegacy)
      .filter(Boolean),
  }));

  return {
    schema_version: "control-room-snapshot-v0",
    as_of: asOf,
    health: {
      status,
      data_freshness_seconds: computeFreshness(asOf),
      active_alerts_count: alerts.length,
    },
    projects: [
      {
        project_id: projectId,
        name: projectId,
        status: mapLegacyStatus(status),
        tracks: [
          {
            track_id: "legacy-units",
            type: "legacy",
            name: "Legacy Units",
            status: mapLegacyStatus(status),
            runs,
          },
        ],
      },
    ],
    alerts,
  };
};

const buildRunIndex = (snapshot) => {
  const projects = toArray(snapshot.projects);
  const runs = [];

  projects.forEach((project) => {
    toArray(project.tracks).forEach((track) => {
      toArray(track.runs).forEach((run) => {
        runs.push({
          project,
          track,
          run,
        });
      });
    });
  });

  return runs;
};

const buildAlertIndex = (snapshot) => toArray(snapshot.alerts);

const setStatusChip = (el, status) => {
  const normalized = normalizeStatus(status);
  el.textContent = status ? status.toUpperCase() : "UNKNOWN";
  el.className = `chip status ${statusClasses[normalized] || "status-unknown"}`;
};

const setText = (id, value) => {
  const el = byId(id);
  if (!el) return;
  el.textContent = safeText(value);
};

const setPillState = (el, label, className) => {
  if (!el) return;
  el.textContent = label;
  el.classList.remove("stale", "offline");
  if (className) el.classList.add(className);
};

const flashElement = (el) => {
  if (!el) return;
  el.classList.remove("flash-update");
  void el.offsetWidth;
  el.classList.add("flash-update");
  window.setTimeout(() => {
    el.classList.remove("flash-update");
  }, FLASH_DURATION_MS);
};

const hashPayload = (payload) => JSON.stringify(payload);

const renderHeader = (snapshot, lastRefreshAt) => {
  setText("snapshot-time", snapshot.as_of);
  setText("snapshot-health", safeText(snapshot.health?.status, "Nominal"));
  setText(
    "snapshot-freshness",
    snapshot.health?.data_freshness_seconds !== undefined &&
      snapshot.health?.data_freshness_seconds !== null
      ? `${snapshot.health.data_freshness_seconds}s`
      : "—"
  );
  setText(
    "snapshot-alerts",
    snapshot.health?.active_alerts_count !== undefined
      ? snapshot.health.active_alerts_count
      : "0"
  );
  setText("snapshot-relative", snapshot.as_of ? relativeTime(snapshot.as_of) : "—");
  setText(
    "snapshot-refreshed",
    lastRefreshAt ? relativeTime(lastRefreshAt) : "—"
  );

  const staleness = snapshot.health?.data_freshness_seconds;
  const staleLabel =
    staleness === null || staleness === undefined
      ? "Unknown"
      : staleness > STALE_THRESHOLD_SECONDS
      ? "Stale"
      : "Fresh";
  const staleEl = byId("snapshot-stale");
  setPillState(staleEl, staleLabel, staleLabel === "Stale" ? "stale" : "");
};

const renderFilters = (snapshot) => {
  const projectSelect = byId("filter-project");
  const trackSelect = byId("filter-track");
  const statusSelect = byId("filter-status");
  const ownerSelect = byId("filter-owner");

  if (!projectSelect || !trackSelect || !statusSelect || !ownerSelect) return;

  const projects = toArray(snapshot.projects);
  const tracks = new Map();
  const statuses = new Set();
  const owners = new Map();

  projects.forEach((project) => {
    toArray(project.tracks).forEach((track) => {
      tracks.set(track.track_id, track.name || track.track_id);
      toArray(track.runs).forEach((run) => {
        if (run.status) statuses.add(run.status);
        if (run.owner?.agent_id) {
          owners.set(run.owner.agent_id, run.owner.display_name || run.owner.agent_id);
        }
      });
    });
  });

  fillSelect(projectSelect, projects.map((project) => ({
    value: project.project_id,
    label: project.name || project.project_id,
  })));
  fillSelect(trackSelect, Array.from(tracks.entries()).map(([value, label]) => ({
    value,
    label,
  })));
  fillSelect(statusSelect, Array.from(statuses).sort().map((value) => ({
    value,
    label: value,
  })));
  fillSelect(ownerSelect, Array.from(owners.entries()).map(([value, label]) => ({
    value,
    label,
  })));

  applyFilterFromQuery();
};

const fillSelect = (select, options) => {
  const current = select.value;
  select.innerHTML = '<option value="">All</option>';
  options.forEach((option) => {
    const node = document.createElement("option");
    node.value = option.value;
    node.textContent = option.label;
    select.appendChild(node);
  });
  if (current) select.value = current;
};

const applyFilterFromQuery = () => {
  const params = new URLSearchParams(window.location.search);
  const applyValue = (id, key) => {
    const el = byId(id);
    if (!el) return;
    const value = params.get(key);
    if (value) el.value = value;
  };
  applyValue("filter-project", "project");
  applyValue("filter-track", "track");
  applyValue("filter-status", "status");
  applyValue("filter-owner", "owner");
  applyValue("filter-search", "search");
};

const updateFilterQuery = () => {
  const filters = collectFilters();
  const params = new URLSearchParams(window.location.search);
  Object.entries(filters).forEach(([key, value]) => {
    if (value) {
      params.set(key, value);
    } else {
      params.delete(key);
    }
  });
  const newUrl = `${window.location.pathname}?${params.toString()}`;
  window.history.replaceState({}, "", newUrl);
};

const collectFilters = () => ({
  project: byId("filter-project")?.value || "",
  track: byId("filter-track")?.value || "",
  status: byId("filter-status")?.value || "",
  owner: byId("filter-owner")?.value || "",
  search: (byId("filter-search")?.value || "").toLowerCase(),
});

const matchesFilter = (item, filters) => {
  if (filters.project && item.project.project_id !== filters.project) return false;
  if (filters.track && item.track.track_id !== filters.track) return false;
  if (filters.status && item.run.status !== filters.status) return false;
  if (filters.owner && item.run.owner?.agent_id !== filters.owner) return false;
  if (filters.search) {
    const haystack = [
      item.project.name,
      item.track.name,
      item.run.run_id,
      item.run.next_action,
      item.run.owner?.display_name,
    ]
      .filter(Boolean)
      .join(" ")
      .toLowerCase();
    if (!haystack.includes(filters.search)) return false;
  }
  return true;
};

const setEmptyState = (id, message, isError = false) => {
  const el = byId(id);
  if (!el) return;
  el.innerHTML = `<div class="empty${isError ? " error" : ""}">${message}</div>`;
};

const buildRunCard = (item) => {
  const { project, track, run } = item;
  const card = document.createElement("div");
  card.className = "run-card";
  card.dataset.runId = run.run_id || "unknown";
  card.dataset.hash = hashPayload({ project, track, run });

  const header = document.createElement("div");
  header.className = "run-header";

  const title = document.createElement("div");
  title.className = "run-title";
  title.innerHTML = `
    <div class="run-name">${safeText(run.run_id)}</div>
    <div class="run-subtitle">${safeText(project.name)} · ${safeText(track.name)}</div>
  `;

  const statusChip = document.createElement("span");
  setStatusChip(statusChip, run.status);
  const statusWrap = document.createElement("div");
  statusWrap.className = "status-chip-group";
  statusWrap.innerHTML = explainPanelHtml(
    `info-run-status-${safeId(run.run_id)}`,
    "Status",
    explainers.runStatus,
    "projects[].tracks[].runs[].status"
  );
  statusWrap.appendChild(statusChip);

  const actions = document.createElement("div");
  actions.className = "run-actions";

  const toggleId = `run-extra-${safeId(run.run_id)}`;
  const toggleButton = document.createElement("button");
  toggleButton.type = "button";
  toggleButton.className = "button ghost";
  toggleButton.setAttribute("aria-expanded", "false");
  toggleButton.setAttribute("aria-controls", toggleId);
  toggleButton.textContent = "Expand";

  const openButton = document.createElement("button");
  openButton.type = "button";
  openButton.className = "button primary";
  openButton.id = `open-run-${safeId(run.run_id)}`;
  openButton.textContent = "Open";
  openButton.addEventListener("click", () => {
    openDrawer({ project, track, run });
  });

  actions.appendChild(toggleButton);
  actions.appendChild(openButton);

  const meta = document.createElement("div");
  meta.className = "run-meta";
  meta.innerHTML = `
    <div>${explainPanelHtml(
      `info-run-owner-${safeId(run.run_id)}`,
      "Owner",
      explainers.runOwner,
      "projects[].tracks[].runs[].owner.display_name"
    )} ${safeText(run.owner?.display_name)}</div>
    <div>${explainPanelHtml(
      `info-run-updated-${safeId(run.run_id)}`,
      "Updated",
      explainers.runUpdated,
      "projects[].tracks[].runs[].last_update_at"
    )} ${relativeTime(run.last_update_at)}</div>
    <div>${explainPanelHtml(
      `info-run-failures-${safeId(run.run_id)}`,
      "Failures",
      explainers.runFailures,
      "projects[].tracks[].runs[].failure_count"
    )} ${safeText(run.failure_count, 0)}</div>
    <div>${explainPanelHtml(
      `info-run-next-${safeId(run.run_id)}`,
      "Next",
      explainers.runNext,
      "projects[].tracks[].runs[].next_action"
    )} ${safeText(run.next_action)}</div>
  `;

  const extra = document.createElement("div");
  extra.className = "run-extra";
  extra.id = toggleId;

  const metrics = document.createElement("div");
  metrics.className = "chip-row";
  if (toArray(run.metrics_summary).length > 0) {
    const metricsLabel = document.createElement("span");
    metricsLabel.innerHTML = explainPanelHtml(
      `info-run-metrics-${safeId(run.run_id)}`,
      "Metrics",
      explainers.runMetrics,
      "projects[].tracks[].runs[].metrics_summary[]"
    );
    metrics.appendChild(metricsLabel);
  }
  toArray(run.metrics_summary).forEach((metric) => {
    const chip = document.createElement("span");
    chip.className = "chip neutral";
    chip.textContent = `${metric.name}: ${metricValue(metric)}`;
    metrics.appendChild(chip);
  });

  const artifacts = document.createElement("div");
  artifacts.className = "artifact-links";
  if (toArray(run.artifact_refs).length > 0) {
    const artifactLabel = document.createElement("span");
    artifactLabel.innerHTML = explainPanelHtml(
      `info-run-artifacts-${safeId(run.run_id)}`,
      "Artifacts",
      explainers.runArtifacts,
      "projects[].tracks[].runs[].artifact_refs[]"
    );
    artifacts.appendChild(artifactLabel);
  }
  toArray(run.artifact_refs).forEach((artifact) => {
    const link = document.createElement("a");
    link.href = artifact.href || "#";
    link.textContent = artifact.label || artifact.artifact_id;
    artifacts.appendChild(link);
  });

  const todoList = document.createElement("div");
  todoList.className = "todo-list";

  if (toArray(run.todos).length === 0) {
    todoList.innerHTML = '<div class="empty">No todos assigned.</div>';
  } else {
    toArray(run.todos).forEach((todo) => {
      const todoItem = document.createElement("div");
      todoItem.className = "todo-item";
      todoItem.innerHTML = `
        <div>
          <div class="todo-title">${safeText(todo.title)}</div>
          <div class="todo-meta">
            ${safeText(todo.status)} · ${relativeTime(todo.updated_at)} · ${safeText(
        todo.owner_agent_id
      )}
          </div>
          <div class="todo-meta">${safeText(todo.blocking_reason)}</div>
        </div>
      `;
      const refs = document.createElement("div");
      refs.className = "todo-artifacts";
      toArray(todo.artifact_refs).forEach((artifact) => {
        const link = document.createElement("a");
        link.href = artifact.href || "#";
        link.textContent = artifact.label || artifact.artifact_id;
        refs.appendChild(link);
      });
      todoItem.appendChild(refs);
      todoList.appendChild(todoItem);
    });
  }

  extra.appendChild(metrics);
  if (artifacts.children.length > 0) extra.appendChild(artifacts);
  extra.appendChild(todoList);

  toggleButton.addEventListener("click", () => {
    const isOpen = extra.classList.toggle("is-open");
    toggleButton.setAttribute("aria-expanded", String(isOpen));
    toggleButton.textContent = isOpen ? "Collapse" : "Expand";
  });

  header.appendChild(title);
  header.appendChild(statusWrap);
  header.appendChild(actions);

  card.appendChild(header);
  card.appendChild(meta);
  card.appendChild(extra);

  return card;
};

const renderWorkboard = (snapshot, options = {}) => {
  const list = byId("workboard-list");
  if (!list) return;
  const filters = collectFilters();
  const runs = buildRunIndex(snapshot).filter((item) =>
    matchesFilter(item, filters)
  );

  if (runs.length === 0) {
    list.innerHTML = '<div class="empty">No runs match current filters.</div>';
    return;
  }

  if (list.querySelector(".empty")) {
    list.innerHTML = "";
  }

  const scrollTop = list.scrollTop;
  const existing = new Map();
  list.querySelectorAll(".run-card").forEach((card) => {
    existing.set(card.dataset.runId, card);
  });

  runs.forEach((item) => {
    const runId = item.run.run_id || "unknown";
    const nextHash = hashPayload(item);
    const current = existing.get(runId);
    if (!current) {
      const newCard = buildRunCard(item);
      list.appendChild(newCard);
      if (options.flash) flashElement(newCard);
      return;
    }
    if (current.dataset.hash !== nextHash) {
      const newCard = buildRunCard(item);
      current.replaceWith(newCard);
      if (options.flash) flashElement(newCard);
    } else {
      list.appendChild(current);
    }
    existing.delete(runId);
  });

  existing.forEach((card) => card.remove());
  list.scrollTop = scrollTop;
};

const renderSpotlight = (snapshot) => {
  const spotlight = byId("failure-spotlight");
  if (!spotlight) return;
  const runs = buildRunIndex(snapshot)
    .map((item) => ({
      ...item,
      failure_count: item.run.failure_count || 0,
    }))
    .filter((item) => item.failure_count > 0)
    .sort((a, b) => b.failure_count - a.failure_count)
    .slice(0, 5);

  spotlight.innerHTML = "";

  if (runs.length === 0) {
    spotlight.innerHTML = '<div class="empty">No failures reported.</div>';
    return;
  }

  runs.forEach((item) => {
    const card = document.createElement("div");
    card.className = "spotlight-card";
    const failureLabel = explainPanelHtml(
      `info-spotlight-failures-${safeId(item.run.run_id)}`,
      "Failures",
      explainers.spotlightFailures,
      "projects[].tracks[].runs[].failure_count"
    );
    card.innerHTML = `
      <div class="spotlight-title">${safeText(item.run.run_id)}</div>
      <div class="spotlight-meta">${safeText(item.project.name)} · ${safeText(
      item.track.name
    )}</div>
      <div class="spotlight-meta">${failureLabel} ${safeText(
      item.run.failure_count
    )}</div>
    `;
    spotlight.appendChild(card);
  });
};

const renderTodoFeed = (snapshot) => {
  const feed = byId("todo-feed");
  if (!feed) return;
  const todos = [];
  buildRunIndex(snapshot).forEach((item) => {
    toArray(item.run.todos).forEach((todo) => {
      todos.push({
        todo,
        run: item.run,
        project: item.project,
        track: item.track,
      });
    });
  });

  todos.sort(
    (a, b) =>
      new Date(b.todo.updated_at || 0).getTime() -
      new Date(a.todo.updated_at || 0).getTime()
  );

  feed.innerHTML = "";

  if (todos.length === 0) {
    feed.innerHTML = '<div class="empty">No open todos.</div>';
    return;
  }

  todos.slice(0, 8).forEach((item) => {
    const row = document.createElement("div");
    row.className = "todo-feed-row";
    row.innerHTML = `
      <div>
        <div class="todo-title">${safeText(item.todo.title)}</div>
        <div class="todo-meta">${safeText(item.project.name)} · ${safeText(
      item.track.name
    )} · ${safeText(item.run.run_id)}</div>
      </div>
      <div class="todo-meta">${safeText(item.todo.status)} · ${relativeTime(
      item.todo.updated_at
    )}</div>
    `;
    feed.appendChild(row);
  });
};

const buildHierarchyNodeMap = (snapshot) => {
  const nodes = new Map();
  const projects = toArray(snapshot.projects);
  projects.forEach((project) => {
    nodes.set(`project:${project.project_id}`, {
      label: project.name || project.project_id,
      status: project.status,
      extra: `${toArray(project.tracks).length} tracks`,
      data: project,
    });

    toArray(project.tracks).forEach((track) => {
      nodes.set(`track:${track.track_id}`, {
        label: track.name || track.track_id,
        status: track.status,
        extra: `${toArray(track.runs).length} runs · ${safeText(track.type)}`,
        data: track,
      });

      toArray(track.runs).forEach((run) => {
        nodes.set(`run:${run.run_id}`, {
          label: run.run_id,
          status: run.status,
          extra: `${safeText(run.owner?.display_name)} · ${safeText(run.next_action)}`,
          data: run,
        });

        if (run.owner?.agent_id) {
          nodes.set(`agent:${run.owner.agent_id}`, {
            label: run.owner.display_name || run.owner.agent_id,
            status: run.owner.status || "active",
            extra: run.owner.role || "",
            data: run.owner,
          });

          toArray(run.todos).forEach((todo) => {
            nodes.set(`todo:${todo.todo_id}`, {
              label: todo.title || todo.todo_id,
              status: todo.status,
              extra: `Updated ${relativeTime(todo.updated_at)}`,
              data: todo,
            });
          });
        }
      });
    });
  });
  return nodes;
};

const buildHierarchySignature = (nodeMap) =>
  Array.from(nodeMap.keys()).join("|");

const createHierarchyNode = (key, nodeData) => {
  const statusId = `info-node-status-${safeId(key)}`;
  const node = document.createElement("button");
  node.type = "button";
  node.className = "hierarchy-node";
  node.dataset.nodeKey = key;
  node.dataset.hash = hashPayload(nodeData);
  node.innerHTML = `
    <div class="hierarchy-node-header">
      <span class="hierarchy-node-title">${nodeData.label}</span>
      <span class="status-chip-group">
        ${explainPanelHtml(statusId, "Status", explainers.nodeStatus, "status")}
        <span class="chip status">${safeText(nodeData.status).toUpperCase()}</span>
      </span>
    </div>
    <div class="hierarchy-node-meta">${safeText(nodeData.extra)}</div>
  `;
  const chip = node.querySelector(".chip.status");
  setStatusChip(chip, nodeData.status);
  return node;
};

const renderHierarchy = (snapshot, options = {}) => {
  const tree = byId("hierarchy-tree");
  if (!tree) return;
  tree.innerHTML = "";

  const nodeMap = buildHierarchyNodeMap(snapshot);
  currentHierarchySignature = buildHierarchySignature(nodeMap);
  hierarchyNodeIndex = new Map();

  const projects = toArray(snapshot.projects);
  if (projects.length === 0) {
    tree.innerHTML = '<div class="empty">No hierarchy data available.</div>';
    return;
  }

  projects.forEach((project) => {
    const projectNode = createHierarchyNode(
      `project:${project.project_id}`,
      nodeMap.get(`project:${project.project_id}`)
    );
    hierarchyNodeIndex.set(`project:${project.project_id}`, {
      type: "project",
      data: project,
    });

    const projectGroup = document.createElement("div");
    projectGroup.className = "hierarchy-group";
    projectGroup.appendChild(projectNode);

    toArray(project.tracks).forEach((track) => {
      const trackNode = createHierarchyNode(
        `track:${track.track_id}`,
        nodeMap.get(`track:${track.track_id}`)
      );
      hierarchyNodeIndex.set(`track:${track.track_id}`, {
        type: "track",
        data: track,
      });
      const trackGroup = document.createElement("div");
      trackGroup.className = "hierarchy-group nested";
      trackGroup.appendChild(trackNode);

      toArray(track.runs).forEach((run) => {
        const runNode = createHierarchyNode(
          `run:${run.run_id}`,
          nodeMap.get(`run:${run.run_id}`)
        );
        hierarchyNodeIndex.set(`run:${run.run_id}`, { type: "run", data: run });
        const runGroup = document.createElement("div");
        runGroup.className = "hierarchy-group nested";
        runGroup.appendChild(runNode);

        if (run.owner?.agent_id) {
          const agentNode = createHierarchyNode(
            `agent:${run.owner.agent_id}`,
            nodeMap.get(`agent:${run.owner.agent_id}`)
          );
          hierarchyNodeIndex.set(`agent:${run.owner.agent_id}`, {
            type: "agent",
            data: run.owner,
          });
          const agentGroup = document.createElement("div");
          agentGroup.className = "hierarchy-group nested";
          agentGroup.appendChild(agentNode);

          toArray(run.todos).forEach((todo) => {
            const todoNode = createHierarchyNode(
              `todo:${todo.todo_id}`,
              nodeMap.get(`todo:${todo.todo_id}`)
            );
            hierarchyNodeIndex.set(`todo:${todo.todo_id}`, {
              type: "todo",
              data: todo,
            });
            const todoGroup = document.createElement("div");
            todoGroup.className = "hierarchy-group nested";
            todoGroup.appendChild(todoNode);
            agentGroup.appendChild(todoGroup);
          });
          runGroup.appendChild(agentGroup);
        }
        trackGroup.appendChild(runGroup);
      });
      projectGroup.appendChild(trackGroup);
    });

    tree.appendChild(projectGroup);
  });

  if (options.flash) {
    tree.querySelectorAll(".hierarchy-node").forEach((node) => {
      flashElement(node);
    });
  }
};

const updateHierarchyNodes = (snapshot, options = {}) => {
  const tree = byId("hierarchy-tree");
  if (!tree) return;

  const nodeMap = buildHierarchyNodeMap(snapshot);
  const signature = buildHierarchySignature(nodeMap);
  const nodeCount = tree.querySelectorAll(".hierarchy-node").length;
  if (signature !== currentHierarchySignature || nodeCount !== nodeMap.size) {
    const scrollTop = tree.scrollTop;
    renderHierarchy(snapshot, options);
    tree.scrollTop = scrollTop;
    return;
  }

  hierarchyNodeIndex = new Map();
  nodeMap.forEach((nodeData, key) => {
    const node = tree.querySelector(`[data-node-key="${key}"]`);
    if (!node) return;
    const nextHash = hashPayload(nodeData);
    if (node.dataset.hash !== nextHash) {
      node.dataset.hash = nextHash;
      const title = node.querySelector(".hierarchy-node-title");
      const meta = node.querySelector(".hierarchy-node-meta");
      const chip = node.querySelector(".chip.status");
      if (title) title.textContent = nodeData.label;
      if (meta) meta.textContent = safeText(nodeData.extra);
      if (chip) setStatusChip(chip, nodeData.status);
      if (options.flash) flashElement(node);
    }
    const [type] = key.split(":");
    hierarchyNodeIndex.set(key, { type, data: nodeData.data });
  });
};

const renderNodeDetail = (panel, entry) => {
  panel.innerHTML = "";
  const header = document.createElement("div");
  header.className = "detail-header";
  header.textContent = `${entry.type.toUpperCase()} · ${safeText(
    entry.data.name || entry.data.run_id || entry.data.todo_id || entry.data.agent_id
  )}`;

  const list = document.createElement("div");
  list.className = "detail-list";

  Object.entries(entry.data).forEach(([key, value]) => {
    if (Array.isArray(value)) return;
    if (value && typeof value === "object") return;
    const row = document.createElement("div");
    row.className = "detail-row";
    row.innerHTML = `<span>${key}</span><span>${safeText(value)}</span>`;
    list.appendChild(row);
  });

  const artifacts = document.createElement("div");
  artifacts.className = "detail-artifacts";
  const artifactRefs = toArray(entry.data.artifact_refs);
  if (artifactRefs.length > 0) {
    const title = document.createElement("div");
    title.className = "detail-subtitle";
    title.textContent = "Artifacts";
    artifacts.appendChild(title);
    artifactRefs.forEach((artifact) => {
      const link = document.createElement("a");
      link.href = artifact.href || "#";
      link.textContent = artifact.label || artifact.artifact_id;
      artifacts.appendChild(link);
    });
  }

  panel.appendChild(header);
  if (list.children.length > 0) panel.appendChild(list);
  if (artifactRefs.length > 0) panel.appendChild(artifacts);
};

const buildAlertCard = (alert) => {
  const card = document.createElement("div");
  card.className = "alert-card";
  card.dataset.alertId = alert.alert_id || "alert";
  card.dataset.hash = hashPayload(alert);
  const severityId = `info-alert-severity-${safeId(alert.alert_id)}`;
  const runInfoId = `info-alert-run-${safeId(alert.alert_id)}`;
  card.innerHTML = `
    <div class="alert-header">
      <span class="status-chip-group">
        ${explainPanelHtml(
          severityId,
          "Severity",
          explainers.alertSeverity,
          "alerts[].severity"
        )}
        <span class="chip ${alert.severity}">${safeText(alert.severity)}</span>
      </span>
      <span>${relativeTime(alert.timestamp)}</span>
    </div>
    <div class="alert-message">${safeText(alert.message)}</div>
    <div class="alert-meta">${explainPanelHtml(
      runInfoId,
      "Run",
      explainers.alertRun,
      "alerts[].run_id"
    )} ${safeText(alert.run_id)}</div>
  `;
  const refs = document.createElement("div");
  refs.className = "alert-artifacts";
  toArray(alert.artifact_refs).forEach((artifact) => {
    const link = document.createElement("a");
    link.href = artifact.href || "#";
    link.textContent = artifact.label || artifact.artifact_id;
    refs.appendChild(link);
  });
  card.appendChild(refs);
  return card;
};

const renderAlerts = (snapshot, options = {}) => {
  const alerts = byId("alerts-rail");
  if (!alerts) return;
  const alertItems = buildAlertIndex(snapshot);

  if (alertItems.length === 0) {
    alerts.innerHTML = '<div class="empty">No alerts.</div>';
    return;
  }

  if (alerts.querySelector(".empty")) {
    alerts.innerHTML = "";
  }

  const scrollTop = alerts.scrollTop;
  const existing = new Map();
  alerts.querySelectorAll(".alert-card").forEach((card) => {
    existing.set(card.dataset.alertId, card);
  });

  alertItems.forEach((alert) => {
    const alertId = alert.alert_id || "alert";
    const nextHash = hashPayload(alert);
    const current = existing.get(alertId);
    if (!current) {
      const newCard = buildAlertCard(alert);
      alerts.appendChild(newCard);
      if (options.flash) flashElement(newCard);
      return;
    }
    if (current.dataset.hash !== nextHash) {
      const newCard = buildAlertCard(alert);
      current.replaceWith(newCard);
      if (options.flash) flashElement(newCard);
    } else {
      alerts.appendChild(current);
    }
    existing.delete(alertId);
  });

  existing.forEach((card) => card.remove());
  alerts.scrollTop = scrollTop;
};

const renderDrawerContent = (payload) => {
  const drawerBody = byId("drawer-body");
  const drawerTitle = byId("drawer-title");
  const drawerSubtitle = byId("drawer-subtitle");
  if (!drawerBody || !drawerTitle || !drawerSubtitle) return;

  if (!payload) {
    drawerTitle.textContent = "Run detail";
    drawerSubtitle.textContent = "Select a run to inspect.";
    drawerBody.innerHTML = '<div class="empty">No run selected.</div>';
    return;
  }

  const { project, track, run } = payload;
  drawerTitle.textContent = `Run · ${safeText(run.run_id)}`;
  drawerSubtitle.textContent = `${safeText(project.name)} · ${safeText(track.name)}`;
  drawerBody.innerHTML = "";

  const summary = document.createElement("div");
  summary.className = "drawer-section";
  summary.innerHTML = `
    <div class="detail-list">
      <div class="detail-row"><span>Status</span><span>${safeText(run.status)}</span></div>
      <div class="detail-row"><span>Owner</span><span>${safeText(run.owner?.display_name)}</span></div>
      <div class="detail-row"><span>Next action</span><span>${safeText(run.next_action)}</span></div>
      <div class="detail-row"><span>Last update</span><span>${relativeTime(run.last_update_at)}</span></div>
      <div class="detail-row"><span>Failures</span><span>${safeText(run.failure_count, 0)}</span></div>
    </div>
  `;

  const metrics = document.createElement("div");
  metrics.className = "drawer-section";
  if (toArray(run.metrics_summary).length > 0) {
    const label = document.createElement("div");
    label.className = "detail-subtitle";
    label.textContent = "Metrics";
    metrics.appendChild(label);
    const chips = document.createElement("div");
    chips.className = "chip-row";
    toArray(run.metrics_summary).forEach((metric) => {
      const chip = document.createElement("span");
      chip.className = "chip neutral";
      chip.textContent = `${metric.name}: ${metricValue(metric)}`;
      chips.appendChild(chip);
    });
    metrics.appendChild(chips);
  } else {
    metrics.innerHTML = '<div class="empty">No metrics provided.</div>';
  }

  const artifacts = document.createElement("div");
  artifacts.className = "drawer-section";
  if (toArray(run.artifact_refs).length > 0) {
    const label = document.createElement("div");
    label.className = "detail-subtitle";
    label.textContent = "Artifacts";
    artifacts.appendChild(label);
    const links = document.createElement("div");
    links.className = "artifact-links";
    toArray(run.artifact_refs).forEach((artifact) => {
      const link = document.createElement("a");
      link.href = artifact.href || "#";
      link.textContent = artifact.label || artifact.artifact_id;
      links.appendChild(link);
    });
    artifacts.appendChild(links);
  } else {
    artifacts.innerHTML = '<div class="empty">No artifacts linked.</div>';
  }

  const todos = document.createElement("div");
  todos.className = "drawer-section";
  const todoLabel = document.createElement("div");
  todoLabel.className = "detail-subtitle";
  todoLabel.textContent = "Todos";
  todos.appendChild(todoLabel);

  const todoList = document.createElement("div");
  todoList.className = "todo-list";
  if (toArray(run.todos).length === 0) {
    todoList.innerHTML = '<div class="empty">No todos assigned.</div>';
  } else {
    toArray(run.todos).forEach((todo) => {
      const todoItem = document.createElement("div");
      todoItem.className = "todo-item";
      todoItem.innerHTML = `
        <div>
          <div class="todo-title">${safeText(todo.title)}</div>
          <div class="todo-meta">${safeText(todo.status)} · ${relativeTime(
        todo.updated_at
      )}</div>
        </div>
      `;
      todoList.appendChild(todoItem);
    });
  }
  todos.appendChild(todoList);

  drawerBody.appendChild(summary);
  drawerBody.appendChild(metrics);
  drawerBody.appendChild(artifacts);
  drawerBody.appendChild(todos);
};

const findRunById = (snapshot, runId) => {
  if (!snapshot || !runId) return null;
  return buildRunIndex(snapshot).find((item) => item.run.run_id === runId) || null;
};

const updateDrawerIfOpen = (snapshot) => {
  const drawer = byId("run-drawer");
  if (!drawer || !drawer.classList.contains("is-open")) return;
  if (!selectedRunId) return;
  const match = findRunById(snapshot, selectedRunId);
  if (match) {
    renderDrawerContent(match);
  }
};

let lastRefreshAt = null;
let refreshTimer = null;
let pollingTimer = null;
let focusTrapCleanup = null;
let currentSnapshot = null;
let currentHierarchySignature = null;
let hierarchyNodeIndex = new Map();
let selectedRunId = null;
let transportMode = "POLLING";
let lastErrorMessage = null;
let sseSource = null;
let sseRetryTimer = null;
let sseRetryDelayMs = SSE_RETRY_BASE_MS;
let explainEscapeBound = false;

const trapFocus = (container) => {
  const selectors = [
    "a[href]",
    "button",
    "textarea",
    "input",
    "select",
    "[tabindex]:not([tabindex='-1'])",
  ];
  const focusable = Array.from(container.querySelectorAll(selectors.join(", ")))
    .filter((el) => !el.hasAttribute("disabled"));
  if (focusable.length === 0) return () => {};
  const first = focusable[0];
  const last = focusable[focusable.length - 1];

  const handleKeydown = (event) => {
    if (event.key !== "Tab") return;
    if (event.shiftKey && document.activeElement === first) {
      event.preventDefault();
      last.focus();
    } else if (!event.shiftKey && document.activeElement === last) {
      event.preventDefault();
      first.focus();
    }
  };

  container.addEventListener("keydown", handleKeydown);
  return () => container.removeEventListener("keydown", handleKeydown);
};

const openDrawer = (payload) => {
  const drawer = byId("run-drawer");
  if (!drawer) return;
  const panel = drawer.querySelector(".drawer-panel");
  const closeButton = drawer.querySelector("button[data-drawer-close]");
  const lastFocused = document.activeElement;

  selectedRunId = payload?.run?.run_id || null;
  renderDrawerContent(payload);
  drawer.classList.add("is-open");
  drawer.setAttribute("aria-hidden", "false");

  if (closeButton) {
    closeButton.focus();
  }

  if (panel) {
    if (focusTrapCleanup) focusTrapCleanup();
    focusTrapCleanup = trapFocus(panel);
  }

  drawer.dataset.lastFocusId = lastFocused?.id || "";
};

const closeDrawer = () => {
  const drawer = byId("run-drawer");
  if (!drawer) return;
  drawer.classList.remove("is-open");
  drawer.setAttribute("aria-hidden", "true");
  if (focusTrapCleanup) focusTrapCleanup();
  focusTrapCleanup = null;
  selectedRunId = null;

  const lastFocusId = drawer.dataset.lastFocusId;
  if (lastFocusId) {
    const el = byId(lastFocusId);
    if (el) el.focus();
  }
};

const initDrawer = () => {
  const drawer = byId("run-drawer");
  if (!drawer) return;
  drawer.querySelectorAll("[data-drawer-close]").forEach((el) => {
    el.addEventListener("click", closeDrawer);
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && drawer.classList.contains("is-open")) {
      closeDrawer();
    }
  });
};

const initHierarchySelection = () => {
  const tree = byId("hierarchy-tree");
  if (!tree) return;
  if (tree.dataset.bound === "true") return;
  tree.dataset.bound = "true";
  tree.addEventListener("click", (event) => {
    const target = event.target.closest(".hierarchy-node");
    if (!target) return;
    const key = target.dataset.nodeKey;
    const entry = hierarchyNodeIndex.get(key);
    if (!entry) return;
    const detailPanel = byId("node-detail");
    if (!detailPanel) return;
    renderNodeDetail(detailPanel, entry);
  });
};

const applyUpdate = (snapshot, options = {}) => {
  currentSnapshot = snapshot;
  renderHeader(snapshot, lastRefreshAt);
  renderFilters(snapshot);
  renderWorkboard(snapshot, options);
  renderSpotlight(snapshot);
  renderTodoFeed(snapshot);
  updateHierarchyNodes(snapshot, options);
  renderAlerts(snapshot, options);
  updateDrawerIfOpen(snapshot);
  initExplainPanels();
};

const setConnectionStatus = (status, message = null) => {
  const label = byId("snapshot-status");
  if (!label) return;
  label.classList.remove("offline", "live", "polling");
  const normalized = status.toUpperCase();
  if (normalized === "LIVE") label.classList.add("live");
  if (normalized === "POLLING") label.classList.add("polling");
  if (normalized === "OFFLINE") label.classList.add("offline");
  label.textContent = normalized;
  label.title = message || "";
  transportMode = normalized;
  lastErrorMessage = message;
};

const loadSnapshotWithFallback = async () => {
  const sources = getSnapshotSources();
  let lastError = null;
  for (const source of sources) {
    try {
      const raw = await fetchSnapshot(source.path);
      if (source.type === "legacy") {
        return normalizeLegacySnapshot(raw);
      }
      return normalizeControlRoomSnapshot(raw);
    } catch (error) {
      lastError = error;
    }
  }
  throw lastError || new Error("No snapshot sources available");
};

const getStreamUrl = () => {
  const params = new URLSearchParams(window.location.search);
  return params.get("stream") || STREAM_ENDPOINT;
};

const stopLiveTransport = () => {
  if (sseSource) {
    sseSource.close();
    sseSource = null;
  }
};

const clearSseRetry = () => {
  if (sseRetryTimer) {
    clearTimeout(sseRetryTimer);
    sseRetryTimer = null;
  }
};

const resetSseBackoff = () => {
  sseRetryDelayMs = SSE_RETRY_BASE_MS;
  clearSseRetry();
};

const scheduleSseReconnect = () => {
  if (!window.EventSource) return;
  if (sseRetryTimer) return;
  const delay = sseRetryDelayMs;
  sseRetryTimer = window.setTimeout(() => {
    sseRetryTimer = null;
    const started = startLiveTransport();
    if (!started) scheduleSseReconnect();
  }, delay);
  sseRetryDelayMs = Math.min(sseRetryDelayMs * 2, SSE_RETRY_MAX_MS);
};

const startLiveTransport = () => {
  if (!window.EventSource) return false;
  stopLiveTransport();
  clearSseRetry();
  try {
    const source = new EventSource(getStreamUrl());
    sseSource = source;
    source.addEventListener("open", () => {
      resetSseBackoff();
      setConnectionStatus("LIVE");
      if (pollingTimer) {
        clearInterval(pollingTimer);
        pollingTimer = null;
      }
    });
    source.addEventListener("snapshot", (event) => {
      try {
        const raw = JSON.parse(event.data);
        const snapshot = normalizeControlRoomSnapshot(raw);
        lastRefreshAt = new Date().toISOString();
        applyUpdate(snapshot, { flash: true });
        setConnectionStatus("LIVE");
      } catch (error) {
        console.error(error);
      }
    });
    source.addEventListener("error", (event) => {
      console.warn("SSE error", event);
      stopLiveTransport();
      setConnectionStatus("POLLING", "SSE disconnected");
      startPollingFallback();
      scheduleSseReconnect();
    });
    return true;
  } catch (error) {
    console.error(error);
    return false;
  }
};

const startPollingFallback = () => {
  const load = async () => {
    try {
      const snapshot = await loadSnapshotWithFallback();
      lastRefreshAt = new Date().toISOString();
      applyUpdate(snapshot, { flash: true });
      if (transportMode !== "POLLING") {
        setConnectionStatus("POLLING");
      }
    } catch (error) {
      const message = error?.message || "Polling failed";
      const shouldLog = message !== lastErrorMessage;
      setConnectionStatus("OFFLINE", message);
      setEmptyState("workboard-list", "Snapshot unavailable.", true);
      setEmptyState("failure-spotlight", "Snapshot unavailable.", true);
      setEmptyState("todo-feed", "Snapshot unavailable.", true);
      setEmptyState("hierarchy-tree", "Snapshot unavailable.", true);
      setEmptyState("alerts-rail", "Snapshot unavailable.", true);
      if (shouldLog) {
        console.error(error);
      }
    }
  };

  if (pollingTimer) clearInterval(pollingTimer);
  if (transportMode !== "POLLING") {
    setConnectionStatus("POLLING");
  }
  load();
  if (refreshTimer) clearInterval(refreshTimer);
  refreshTimer = setInterval(() => {
    if (lastRefreshAt) {
      setText("snapshot-refreshed", relativeTime(lastRefreshAt));
    }
  }, REFRESH_LABEL_INTERVAL_MS);
  pollingTimer = setInterval(load, POLL_INTERVAL_MS);
};

const stopPollingFallback = () => {
  if (pollingTimer) {
    clearInterval(pollingTimer);
    pollingTimer = null;
  }
  if (refreshTimer) {
    clearInterval(refreshTimer);
    refreshTimer = null;
  }
};

const shutdownTransport = () => {
  stopLiveTransport();
  clearSseRetry();
  stopPollingFallback();
};

const initControls = () => {
  const controls = [
    "filter-project",
    "filter-track",
    "filter-status",
    "filter-owner",
    "filter-search",
  ];
  controls.forEach((id) => {
    const control = byId(id);
    if (!control) return;
    control.addEventListener("change", () => {
      updateFilterQuery();
      loadSnapshotWithFallback()
        .then((snapshot) => applyUpdate(snapshot))
        .catch(console.error);
    });
    control.addEventListener("input", () => {
      updateFilterQuery();
      loadSnapshotWithFallback()
        .then((snapshot) => applyUpdate(snapshot))
        .catch(console.error);
    });
  });
};

const initJsonKeyToggle = () => {
  const toggle = byId("toggle-json-keys");
  if (!toggle) return;
  toggle.addEventListener("change", () => {
    document.body.classList.toggle("show-json-keys", toggle.checked);
  });
};

const startTransport = () => {
  loadSnapshotWithFallback()
    .then((snapshot) => {
      applyUpdate(snapshot);
      if (transportMode !== "LIVE") {
        setConnectionStatus("POLLING");
      }
    })
    .catch((error) => {
      setConnectionStatus("OFFLINE", error?.message || "Initial load failed");
    });
  const liveStarted = startLiveTransport();
  if (!liveStarted) {
    setConnectionStatus("POLLING", "EventSource unavailable");
    startPollingFallback();
    scheduleSseReconnect();
  }
};

const getSnapshotSources = () => {
  const params = new URLSearchParams(window.location.search);
  const override = params.get("source");
  const apiOverride = params.get("api");
  const snapshotOverride = params.get("snapshot");
  const snapshotEndpoint =
    snapshotOverride || apiOverride || window.CONTROL_ROOM_SNAPSHOT_ENDPOINT || SNAPSHOT_ENDPOINT;

  const sources = [];
  if (override) {
    sources.push({ type: "override", path: override });
  }
  sources.push({ type: "control-room", path: DEFAULT_SNAPSHOT_PATH });
  sources.push({ type: "legacy", path: LEGACY_SNAPSHOT_PATH });
  if (snapshotEndpoint) {
    sources.push({ type: "api", path: snapshotEndpoint });
  }
  return sources;
};

const boot = () => {
  initControls();
  initExplainPanels();
  initJsonKeyToggle();
  initDrawer();
  initHierarchySelection();
  window.addEventListener("beforeunload", shutdownTransport);
  window.addEventListener("pagehide", shutdownTransport);
  startTransport();
};

boot();
